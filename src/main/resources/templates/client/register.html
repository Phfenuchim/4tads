<!DOCTYPE html>
<html lang="pt-br" xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Cadastro de Cliente - GADUS</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" th:href="@{/css/client/register.css}">
    <style>
        /* Para garantir que a mensagem de erro do Bootstrap seja exibida */
        .error-message.client-side-only, .error-message {
            display: none; /* Começa escondido, JS ou Thymeleaf mostrará */
            color: #dc3545;
            font-size: 0.875em;
            margin-top: 0.25rem;
        }
        .form-control.field-error {
            border-color: #dc3545;
        }
    </style>
</head>
<body>
<!-- Header -->
<div th:replace="~{fragments/header :: header}"></div>

<div class="container py-5">
    <div class="col-md-8 mx-auto">
        <h1 class="visually-hidden">Cadastro de Cliente</h1>
        <h2 class="mb-4">Crie sua Conta</h2>

        <!-- Mensagens Globais (Flash Attributes) -->
        <div th:if="${errorMessage}" class="alert alert-danger alert-dismissible fade show" role="alert">
            <span th:text="${errorMessage}"></span>
            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
        </div>
        <div th:if="${successMessage}" class="alert alert-success alert-dismissible fade show" role="alert">
            <span th:text="${successMessage}"></span>
            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
        </div>

        <!-- O objeto do formulário é "client" (CreateClientDTO) -->
        <form method="post" th:action="@{/register}" th:object="${client}" novalidate>
            <div th:if="${#fields.hasErrors('global')}" class="alert alert-danger">
                <ul>
                    <li th:each="err : ${#fields.errors('global')}" th:text="${err}"></li>
                </ul>
            </div>

            <!-- Dados Pessoais -->
            <h3 class="mt-4 mb-3">Dados Pessoais</h3>

            <div class="mb-3">
                <label for="fullName" class="form-label">Nome Completo</label>
                <input type="text" id="fullName" th:field="*{fullName}" class="form-control"
                       th:classappend="${#fields.hasErrors('fullName')} ? 'field-error'"
                       placeholder="Seu nome completo" required
                       oninput="handleFieldInput(this, 'fullName')"
                       oninvalid="handleFieldInvalid(this, 'fullNameClientError', 'O nome é obrigatório')">
                <div class="error-message" th:if="${#fields.hasErrors('fullName')}" th:errors="*{fullName}"></div>
                <div id="fullNameClientError" class="error-message client-side-only"></div>
            </div>

            <div class="mb-3">
                <label for="email" class="form-label">E-mail</label>
                <input type="email" id="email" th:field="*{email}" class="form-control"
                       th:classappend="${#fields.hasErrors('email')} ? 'field-error'"
                       placeholder="seu@email.com" required
                       oninput="handleFieldInput(this, 'email')"
                       oninvalid="handleFieldInvalid(this, 'emailClientError', 'O email é obrigatório.')">
                <div class="error-message" th:if="${#fields.hasErrors('email')}" th:errors="*{email}"></div>
                <div id="emailClientError" class="error-message client-side-only"></div>
            </div>

            <div class="mb-3">
                <label for="cpf" class="form-label">CPF</label>
                <input type="text" id="cpf" th:field="*{cpf}" class="form-control"
                       th:classappend="${#fields.hasErrors('cpf')} ? 'field-error'"
                       placeholder="000.000.000-00" required maxlength="14"
                       oninput="applyCpfMask(this); handleFieldInput(this, 'cpf')"
                       onblur="validateCPF(this, 'cpfClientErrorSpan')"
                       oninvalid="handleFieldInvalid(this, 'cpfClientErrorDiv', 'O CPF é obrigatório.')">
                <div class="error-message" th:if="${#fields.hasErrors('cpf')}" th:errors="*{cpf}"></div>
                <span id="cpfClientErrorSpan" class="error-message client-side-only">CPF inválido.</span>
                <div id="cpfClientErrorDiv" class="error-message client-side-only"></div>
            </div>

            <div class="mb-3">
                <label for="phone" class="form-label">Telefone</label>
                <input type="text" id="phone" th:field="*{phone}" class="form-control"
                       th:classappend="${#fields.hasErrors('phone')} ? 'field-error'"
                       placeholder="(00) 00000-0000" required maxlength="15"
                       oninput="applyPhoneMask(this); handleFieldInput(this, 'phone')"
                       oninvalid="handleFieldInvalid(this, 'phoneClientError', 'O telefone é obrigatório.')">
                <div class="error-message" th:if="${#fields.hasErrors('phone')}" th:errors="*{phone}"></div>
                <div id="phoneClientError" class="error-message client-side-only"></div>
            </div>

            <div class="mb-3">
                <label for="dateBirth" class="form-label">Data de Nascimento</label>
                <input type="date" id="dateBirth" th:field="*{dateBirth}" class="form-control" required
                       min="1900-01-01" th:max="${#temporals.format(#temporals.createNow().minusYears(18), 'yyyy-MM-dd')}"
                oninput="handleDateInput(this); handleFieldInput(this, 'dateBirth')"
                oninvalid="handleDateInvalid(this, 'A data de nascimento é obrigatória.')"
                th:classappend="${#fields.hasErrors('dateBirth')} ? 'field-error'"/>
                <div class="error-message" th:if="${#fields.hasErrors('dateBirth')}" th:errors="*{dateBirth}"></div>
                <div id="dateBirthClientError" class="error-message client-side-only"></div>
            </div>

            <div class="mb-3">
                <label for="gender" class="form-label">Gênero</label>
                <select id="gender" th:field="*{gender}" class="form-control"
                        aria-label="Selecione o gênero"
                        oninput="handleFieldInput(this, 'gender')"
                        oninvalid="handleFieldInvalid(this, 'genderClientError', 'O gênero é obrigatório.')"
                        th:classappend="${#fields.hasErrors('gender')} ? 'field-error'" required>
                    <option value="">Selecione</option>
                    <option value="Masculino">Masculino</option>
                    <option value="Feminino">Feminino</option>
                    <option value="Outro">Outro</option>
                    <option value="Prefiro não informar">Prefiro não informar</option>
                </select>
                <div class="error-message" th:if="${#fields.hasErrors('gender')}" th:errors="*{gender}"></div>
                <div id="genderClientError" class="error-message client-side-only"></div>
            </div>

            <div class="mb-3">
                <label for="password" class="form-label">Senha</label>
                <input type="password" id="password" th:field="*{password}" class="form-control"
                       th:classappend="${#fields.hasErrors('password')} ? 'field-error'"
                       placeholder="Crie uma senha" required
                       oninput="handleFieldInput(this, 'password')"
                       oninvalid="handleFieldInvalid(this, 'passwordClientError', 'A senha é obrigatória.')">
                <div class="error-message" th:if="${#fields.hasErrors('password')}" th:errors="*{password}"></div>
                <div id="passwordClientError" class="error-message client-side-only"></div>
                <small class="text-muted" th:if="${not #fields.hasErrors('password')}">A senha deve ter no mínimo 6 caracteres.</small>
            </div>

            <!-- Título de Endereço - Alterado -->
            <h3 class="mt-4 mb-3">Seu Endereço Principal</h3>
            <p class="text-muted mb-3">Este endereço será usado para entrega e faturamento. Você poderá adicionar outros endereços de entrega após o cadastro.</p>

            <!-- Campos do Endereço Inicial -->
            <div class="row mb-3">
                <div class="col-md-4">
                    <!-- ID e th:field ajustados para initialAddress -->
                    <label for="initialAddressCep" class="form-label">CEP</label>
                    <input type="text" id="initialAddressCep" th:field="*{initialAddress.cep}" class="form-control"
                           th:classappend="${#fields.hasErrors('initialAddress.cep')} ? 'field-error'"
                           placeholder="00000-000" maxlength="9" required
                           oninput="applyCepMask(this); handleFieldInput(this, 'initialAddress.cep')"
                           oninvalid="handleFieldInvalid(this, 'initialAddressCepClientError', 'O CEP é obrigatório.')">
                    <div class="error-message" th:if="${#fields.hasErrors('initialAddress.cep')}" th:errors="*{initialAddress.cep}"></div>
                    <div id="initialAddressCepClientError" class="error-message client-side-only"></div>
                </div>
                <div class="col-md-2 d-flex align-items-end">
                    <!-- O onclick buscarCep() precisará saber quais campos preencher -->
                    <button type="button" class="btn btn-outline-primary w-100" onclick="buscarCep('initialAddress')">Buscar</button>
                </div>
            </div>

            <div class="mb-3">
                <label for="initialAddressStreet" class="form-label">Rua</label>
                <input type="text" id="initialAddressStreet" th:field="*{initialAddress.street}" class="form-control"
                       th:classappend="${#fields.hasErrors('initialAddress.street')} ? 'field-error'" required
                       oninput="handleFieldInput(this, 'initialAddress.street')"
                       oninvalid="handleFieldInvalid(this, 'initialAddressStreetClientError', 'A rua é obrigatória.')">
                <div class="error-message" th:if="${#fields.hasErrors('initialAddress.street')}" th:errors="*{initialAddress.street}"></div>
                <div id="initialAddressStreetClientError" class="error-message client-side-only"></div>
            </div>

            <div class="mb-3">
                <label for="initialAddressNumber" class="form-label">Número</label>
                <input type="text" id="initialAddressNumber" th:field="*{initialAddress.number}" class="form-control"
                       th:classappend="${#fields.hasErrors('initialAddress.number')} ? 'field-error'" required
                       oninput="handleFieldInput(this, 'initialAddress.number')"
                       oninvalid="handleFieldInvalid(this, 'initialAddressNumberClientError', 'O número é obrigatório.')">
                <div class="error-message" th:if="${#fields.hasErrors('initialAddress.number')}" th:errors="*{initialAddress.number}"></div>
                <div id="initialAddressNumberClientError" class="error-message client-side-only"></div>
            </div>

            <div class="mb-3">
                <label for="initialAddressComplement" class="form-label">Complemento</label>
                <input type="text" id="initialAddressComplement" th:field="*{initialAddress.complement}" class="form-control"
                       th:classappend="${#fields.hasErrors('initialAddress.complement')} ? 'field-error'"
                       oninput="handleFieldInput(this, 'initialAddress.complement')">
                <div class="error-message" th:if="${#fields.hasErrors('initialAddress.complement')}" th:errors="*{initialAddress.complement}"></div>
            </div>

            <div class="mb-3">
                <label for="initialAddressDistrict" class="form-label">Bairro</label>
                <input type="text" id="initialAddressDistrict" th:field="*{initialAddress.district}" class="form-control"
                       th:classappend="${#fields.hasErrors('initialAddress.district')} ? 'field-error'" required
                       oninput="handleFieldInput(this, 'initialAddress.district')"
                       oninvalid="handleFieldInvalid(this, 'initialAddressDistrictClientError', 'O bairro é obrigatório.')">
                <div class="error-message" th:if="${#fields.hasErrors('initialAddress.district')}" th:errors="*{initialAddress.district}"></div>
                <div id="initialAddressDistrictClientError" class="error-message client-side-only"></div>
            </div>

            <div class="mb-3">
                <label for="initialAddressCity" class="form-label">Cidade</label>
                <input type="text" id="initialAddressCity" th:field="*{initialAddress.city}" class="form-control"
                       th:classappend="${#fields.hasErrors('initialAddress.city')} ? 'field-error'" required
                       oninput="handleFieldInput(this, 'initialAddress.city')"
                       oninvalid="handleFieldInvalid(this, 'initialAddressCityClientError', 'A cidade é obrigatória.')">
                <div class="error-message" th:if="${#fields.hasErrors('initialAddress.city')}" th:errors="*{initialAddress.city}"></div>
                <div id="initialAddressCityClientError" class="error-message client-side-only"></div>
            </div>

            <div class="mb-3">
                <label for="initialAddressState" class="form-label">Estado</label>
                <input type="text" id="initialAddressState" th:field="*{initialAddress.state}" class="form-control"
                       th:classappend="${#fields.hasErrors('initialAddress.state')} ? 'field-error'" required
                       oninput="handleFieldInput(this, 'initialAddress.state')"
                       oninvalid="handleFieldInvalid(this, 'initialAddressStateClientError', 'O estado é obrigatório.')">
                <div class="error-message" th:if="${#fields.hasErrors('initialAddress.state')}" th:errors="*{initialAddress.state}"></div>
                <div id="initialAddressStateClientError" class="error-message client-side-only"></div>
            </div>

            <div class="mb-3">
                <label for="initialAddressCountry" class="form-label">País</label>
                <input type="text" id="initialAddressCountry" th:field="*{initialAddress.country}" class="form-control"
                       th:classappend="${#fields.hasErrors('initialAddress.country')} ? 'field-error'" required
                       oninput="handleFieldInput(this, 'initialAddress.country')"
                       oninvalid="handleFieldInvalid(this, 'initialAddressCountryClientError', 'O país é obrigatório.')">
                <div class="error-message" th:if="${#fields.hasErrors('initialAddress.country')}" th:errors="*{initialAddress.country}"></div>
                <div id="initialAddressCountryClientError" class="error-message client-side-only"></div>
            </div>

            <!-- REMOVIDO: Input oculto para defaultAddress.default -->
            <!-- REMOVIDO: Select para billingAddress.type -->
            <!-- REMOVIDO: Checkbox para billingAddress.default -->

            <div class="d-grid gap-2"> <!-- Para o botão ocupar a largura total -->
                <button type="submit" class="btn btn-success btn-lg">Cadastrar</button>
            </div>
        </form>
    </div>
</div>

<!-- Footer -->
<div th:replace="~{fragments/footer :: footer}"></div>

<script>
    // Funções de máscara (existentes)
    function applyCpfMask(input) { let value = input.value.replace(/\D/g, ''); if (value.length > 11) value = value.slice(0, 11); value = value.replace(/^(\d{3})(\d)/, '$1.$2'); value = value.replace(/^(\d{3})\.(\d{3})(\d)/, '$1.$2.$3'); value = value.replace(/^(\d{3})\.(\d{3})\.(\d{3})(\d)/, '$1.$2.$3-$4'); input.value = value; }
    function applyPhoneMask(input) { let value = input.value.replace(/\D/g, ''); if (value.length > 11) value = value.slice(0, 11); value = value.replace(/^(\d{2})(\d)/, '($1) $2'); value = value.replace(/(\d{5})(\d)/, '$1-$2'); input.value = value; }
    function applyCepMask(input) { let value = input.value.replace(/\D/g, ''); if (value.length > 8) value = value.slice(0, 8); if (value.length > 5) { value = value.replace(/^(\d{5})(\d)/, '$1-$2'); } input.value = value; }

    // Função buscarCep - AJUSTADA para aceitar um prefixo para os IDs dos campos
    async function buscarCep(addressPrefix) { // 'addressPrefix' será 'initialAddress'
        const cepInput = document.getElementById(addressPrefix + "Cep");
        const cep = cepInput.value.trim().replace(/\D/g, '');

        if (!cep || cep.length !== 8) { alert("Digite um CEP válido."); return; }
        try {
            // Usar Thymeleaf para construir a URL base corretamente (se este script for inline ou processado pelo Thymeleaf)
            const url = `[[@{/cep/}]]${cep}`;
            const res = await fetch(url);
            if (!res.ok) {
                const errorData = await res.json().catch(() => ({ message: 'Erro na busca do CEP. Verifique o CEP e tente novamente.' }));
                alert(errorData.message || `Erro ${res.status}: ${res.statusText}`);
                return;
            }
            const data = await res.json();
            if (data.erro) { // Comum em APIs de CEP brasileiras
                alert("CEP não encontrado. Por favor, verifique o número digitado.");
                return;
            }

            // Mapeamento dos campos usando o prefixo
            const campos = { street: 'Street', district: 'District', city: 'City', state: 'State', country: 'Country' };
            let primeiroCampoVazio = null;

            for (const apiProp in campos) {
                const inputId = addressPrefix + campos[apiProp]; // Ex: initialAddressStreet
                const inputEl = document.getElementById(inputId);
                if (inputEl) {
                    const valor = data[apiProp.toLowerCase()] || (apiProp === 'country' && data.city ? 'Brasil' : ''); // Ajuste para nome da prop da API
                    inputEl.value = valor;
                    if (!primeiroCampoVazio && valor === '') {
                        primeiroCampoVazio = inputEl;
                    }
                    handleFieldInput(inputEl, addressPrefix + '.' + apiProp.toLowerCase()); // Limpa erro de validação do servidor
                }
            }
            const numberInputId = addressPrefix + 'Number';
            (primeiroCampoVazio || document.getElementById(numberInputId)).focus();

        } catch (err) {
            console.error("Erro ao buscar CEP:", err);
            alert("Erro ao buscar o CEP. Verifique sua conexão e tente novamente.");
        }
    }

    // Função de validação de CPF (existente)
    function isValidCPF(cpf) { /* ... sua implementação ... */ return true; } // Mantenha sua implementação

    function validateCPF(input, clientErrorSpanId) { /* ... sua implementação ... */ } // Mantenha sua implementação

    // --- FUNÇÕES DE VALIDAÇÃO DO CLIENTE (EXISTENTES, mas revisadas para consistência) ---

    function clearError(fieldName) {
        // O fieldName aqui deve ser o que o th:field usa (ex: 'fullName', 'initialAddress.cep')
        const field = document.querySelector(`[name='${fieldName.replace(/\./g, "\\.")}']`); // Escapa pontos para o seletor
        if (!field) {
            console.warn("Campo não encontrado para limpar erro:", fieldName);
            return;
        }

        if (typeof field.setCustomValidity === 'function') {
            field.setCustomValidity('');
        }
        field.classList.remove('field-error'); // Remove a classe de erro visual

        // Tenta encontrar o elemento de erro específico do Thymeleaf
        let thymeleafErrorElement = null;
        let currentElement = field;
        // Procura por um irmão que seja o container de erro do Thymeleaf
        while ((currentElement = currentElement.nextElementSibling) != null) {
            if (currentElement.getAttribute('th:errors') === ('*\{' + fieldName + '\}') ||
                (currentElement.classList && currentElement.classList.contains('error-message') && !currentElement.classList.contains('client-side-only'))) {
                thymeleafErrorElement = currentElement;
                break;
            }
        }
        if (thymeleafErrorElement) {
            thymeleafErrorElement.textContent = ''; // Limpa o conteúdo
            thymeleafErrorElement.style.display = 'none'; // Esconde
        }

        // Limpa o elemento de erro client-side (se existir)
        const clientErrorDivId = field.id + 'ClientError';
        const clientErrorDiv = document.getElementById(clientErrorDivId);
        if (clientErrorDiv) {
            clientErrorDiv.textContent = '';
            clientErrorDiv.style.display = 'none';
        }
        if (field.id === 'cpf') { // Caso especial para CPF
            const cpfSpan = document.getElementById('cpfClientErrorSpan');
            if (cpfSpan) cpfSpan.style.display = 'none';
            const cpfDiv = document.getElementById('cpfClientErrorDiv');
            if (cpfDiv) cpfDiv.style.display = 'none';
        }
    }

    function handleFieldInput(inputElement, fieldNameForThymeleaf) {
        if (typeof inputElement.setCustomValidity === 'function') {
            inputElement.setCustomValidity('');
        }
        clearError(fieldNameForThymeleaf); // Usa o nome do campo como no th:field
    }

    function handleFieldInvalid(inputElement, clientErrorDivId, defaultRequiredMessage) {
        let message = '';
        if (inputElement.validity.valueMissing) {
            message = defaultRequiredMessage;
        } else if (inputElement.validity.typeMismatch) {
            message = `Formato inválido para ${inputElement.labels[0] ? inputElement.labels[0].textContent.toLowerCase() : 'este campo'}.`;
        } else if (inputElement.validity.patternMismatch) {
            message = `O valor não corresponde ao padrão exigido para ${inputElement.labels[0] ? inputElement.labels[0].textContent.toLowerCase() : 'este campo'}.`;
        } else {
            message = inputElement.validationMessage || defaultRequiredMessage; // Pega a mensagem do navegador se houver, senão a padrão
        }
        inputElement.setCustomValidity(message); // Define a mensagem para a API de validação do navegador

        const clientErrorDiv = document.getElementById(clientErrorDivId);
        if (clientErrorDiv) {
            clientErrorDiv.textContent = message;
            clientErrorDiv.style.display = 'block';
        }
        inputElement.classList.add('field-error');
    }

    function handleDateInput(inputElement) {
        inputElement.setCustomValidity('');
        const clientErrorDiv = document.getElementById('dateBirthClientError');
        if (clientErrorDiv) {
            clientErrorDiv.textContent = '';
            clientErrorDiv.style.display = 'none';
        }
        handleFieldInput(inputElement, 'dateBirth');
    }

    function handleDateInvalid(inputElement, requiredMessage) {
        let message = '';
        // ... (sua lógica de mensagens de erro de data - mantenha como estava ou ajuste)
        if (inputElement.validity.valueMissing) { message = requiredMessage; }
        else if (inputElement.validity.badInput) { message = 'Data inválida. Verifique se o dia e o mês existem.'; }
        else if (inputElement.validity.rangeOverflow) { message = 'A data não pode ser no futuro.'; }
        else if (inputElement.validity.rangeUnderflow) { message = 'A data é muito antiga ou o usuário é menor de 18 anos.'; }
        else { message = 'Por favor, insira uma data válida.'; }

        inputElement.setCustomValidity(message);
        const clientErrorDiv = document.getElementById('dateBirthClientError');
        if (clientErrorDiv) { clientErrorDiv.textContent = message; clientErrorDiv.style.display = 'block'; }
        inputElement.classList.add('field-error');
    }

    document.addEventListener('DOMContentLoaded', function() {
        const cpfInput = document.getElementById('cpf');
        if (cpfInput) {
            cpfInput.addEventListener('blur', function() {
                validateCPF(this, 'cpfClientErrorSpan');
            });
        }
        // Adiciona event listeners para limpar erros no input para todos os campos relevantes
        document.querySelectorAll('input[oninput*="handleFieldInput"], select[oninput*="handleFieldInput"]').forEach(input => {
            const fieldNameMatch = input.getAttribute('oninput').match(/handleFieldInput\(this, '([^']+)'\)/);
            if (fieldNameMatch && fieldNameMatch[1]) {
                const fieldName = fieldNameMatch[1];
                input.addEventListener('input', () => handleFieldInput(input, fieldName));
            }
        });
    });
</script>
</body>
</html>
