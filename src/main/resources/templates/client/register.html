<!DOCTYPE html>
<html lang="pt-br" xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Cadastro de Cliente - GADUS</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" th:href="@{/css/client/register.css}">
</head>
<body>
<!-- Header -->
<div th:replace="~{fragments/header :: header}"></div>

<div class="container py-5">
    <div class="col-md-8 mx-auto">
        <h1 class="visually-hidden">Cadastro de Usuário</h1> <!-- Apenas para acessibilidade -->
        <h2 class="mb-4">Crie sua Conta</h2>
        <div th:if="${error}" class="alert alert-danger" th:text="${error}"></div>
        <div th:if="${success}" class="alert alert-success" th:text="${success}"></div>

        <form method="post" th:action="@{/register}" th:object="${client}" novalidate>
            <div th:if="${#fields.hasErrors('global')}" class="alert alert-danger">
                <ul>
                    <li th:each="err : ${#fields.errors('global')}" th:text="${err}"></li>
                </ul>
            </div>

            <div class="mb-3">
                <label for="name" class="form-label">Nome Completo</label>
                <input type="text" id="name" th:field="*{fullName}" class="form-control"
                       th:classappend="${#fields.hasErrors('fullName')} ? 'field-error'"
                       placeholder="Seu nome completo" required
                       oninput="handleFieldInput(this, 'fullName')"
                       oninvalid="handleFieldInvalid(this, 'nameClientError', 'O nome é obrigatório')">
                <div class="error-message" th:if="${#fields.hasErrors('fullName')}" th:errors="*{fullName}"></div>
                <div id="nameClientError" class="error-message client-side-only" style="display: none;"></div>
            </div>

            <div class="mb-3">
                <label for="email" class="form-label">E-mail</label>
                <input type="email" id="email" th:field="*{email}" class="form-control"
                       th:classappend="${#fields.hasErrors('email')} ? 'field-error'"
                       placeholder="seu@email.com" required
                       oninput="handleFieldInput(this, 'email')"
                       oninvalid="handleFieldInvalid(this, 'emailClientError', 'O email é obrigatório.')">
                <div class="error-message" th:if="${#fields.hasErrors('email')}" th:errors="*{email}"></div>
                <div id="emailClientError" class="error-message client-side-only" style="display: none;"></div>
            </div>

            <div class="mb-3">
                <label for="cpf" class="form-label">CPF</label>
                <input type="text" id="cpf" th:field="*{cpf}" class="form-control"
                       th:classappend="${#fields.hasErrors('cpf')} ? 'field-error'"
                       placeholder="000.000.000-00" required maxlength="14"
                       oninput="applyCpfMask(this); handleFieldInput(this, 'cpf')"
                       onblur="validateCPF(this, 'cpfClientErrorSpan')"
                       oninvalid="handleFieldInvalid(this, 'cpfClientErrorDiv', 'O CPF é obrigatório.')">
                <div class="error-message" th:if="${#fields.hasErrors('cpf')}" th:errors="*{cpf}"></div>
                <!-- Span para erro específico de formato/validação do CPF (controlado por validateCPF) -->
                <span id="cpfClientErrorSpan" class="error-message client-side-only" style="display: none;">CPF inválido.</span>
                <!-- Div para erro de campo obrigatório (controlado por oninvalid) -->
                <div id="cpfClientErrorDiv" class="error-message client-side-only" style="display: none;"></div>
            </div>

            <div class="mb-3">
                <label for="phone" class="form-label">Telefone</label>
                <input type="text" id="phone" th:field="*{phone}" class="form-control"
                       th:classappend="${#fields.hasErrors('phone')} ? 'field-error'"
                       placeholder="(00) 00000-0000" required maxlength="15"
                       oninput="applyPhoneMask(this); handleFieldInput(this, 'phone')"
                       oninvalid="handleFieldInvalid(this, 'phoneClientError', 'O telefone é obrigatório.')">
                <div class="error-message" th:if="${#fields.hasErrors('phone')}" th:errors="*{phone}"></div>
                <div id="phoneClientError" class="error-message client-side-only" style="display: none;"></div>
            </div>

            <div class="mb-3">
                <label for="dateBirth" class="form-label">Data de Nascimento</label>
                <input type="date" id="dateBirth" th:field="*{dateBirth}" class="form-control" required
                       min="1900-01-01" th:max="${#temporals.format(#temporals.createNow(), 'yyyy-MM-dd')}"
                       oninput="handleDateInput(this); handleFieldInput(this, 'dateBirth')"
                       oninvalid="handleDateInvalid(this, 'A data de nascimento é obrigatória.')"
                       th:classappend="${#fields.hasErrors('dateBirth')} ? 'field-error'"/>
                <div class="error-message" th:if="${#fields.hasErrors('dateBirth')}" th:errors="*{dateBirth}"></div>
                <div id="dateBirthClientError" class="error-message client-side-only" style="display: none;"></div>
            </div>

            <div class="mb-3">
                <label for="gender" class="form-label">Gênero</label>
                <select id="gender" th:field="*{gender}" class="form-control"
                        aria-label="Selecione o gênero"
                        oninput="handleFieldInput(this, 'gender')"
                        oninvalid="handleFieldInvalid(this, 'genderClientError', 'O gênero é obrigatório.')"
                        th:classappend="${#fields.hasErrors('gender')} ? 'field-error'" required>
                    <option value="">Selecione</option>
                    <option value="Masculino">Masculino</option>
                    <option value="Feminino">Feminino</option>
                    <option value="Outro">Outro</option>
                    <option value="Prefiro não informar">Prefiro não informar</option>
                </select>

                <div class="error-message" th:if="${#fields.hasErrors('gender')}" th:errors="*{gender}"></div>
                <div id="genderClientError" class="error-message client-side-only" style="display: none;"></div>
            </div>


            <div class="mb-3">
                <label for="password" class="form-label">Senha</label>
                <input type="password" id="password" th:field="*{password}" class="form-control"
                       th:classappend="${#fields.hasErrors('password')} ? 'field-error'"
                       placeholder="Crie uma senha" required
                       oninput="handleFieldInput(this, 'password')"
                       oninvalid="handleFieldInvalid(this, 'passwordClientError', 'A senha é obrigatória.')">
                <div class="error-message" th:if="${#fields.hasErrors('password')}" th:errors="*{password}"></div>
                <div id="passwordClientError" class="error-message client-side-only" style="display: none;"></div>
                <small class="text-muted" th:text="${#fields.hasErrors('password')} ? '' : 'A senha deve ter no mínimo 6 caracteres'"></small>
            </div>

            <!-- Título de Endereço -->
            <h3 class="mt-4">Endereço de Faturamento</h3>

            <div class="row mb-3">
                <div class="col-md-4">
                    <label for="cep" class="form-label">CEP</label>
                    <input type="text" id="cep" th:field="*{billingAddress.cep}" class="form-control"
                           th:classappend="${#fields.hasErrors('billingAddress.cep')} ? 'field-error'"
                           placeholder="00000-000" maxlength="9" required
                           oninput="applyCepMask(this); handleFieldInput(this, 'billingAddress.cep')"
                           oninvalid="handleFieldInvalid(this, 'cepClientError', 'O CEP é obrigatório.')">
                    <div class="error-message" th:if="${#fields.hasErrors('billingAddress.cep')}" th:errors="*{billingAddress.cep}"></div>
                    <div id="cepClientError" class="error-message client-side-only" style="display: none;"></div>
                </div>
                <div class="col-md-2 d-flex align-items-end">
                    <button type="button" class="btn btn-outline-primary w-100" onclick="buscarCep()">Buscar</button>
                </div>
            </div>

            <div class="mb-3">
                <label for="street" class="form-label">Rua</label>
                <input type="text" id="street" th:field="*{billingAddress.street}" class="form-control"
                       th:classappend="${#fields.hasErrors('billingAddress.street')} ? 'field-error'" required
                       oninput="handleFieldInput(this, 'billingAddress.street')"
                       oninvalid="handleFieldInvalid(this, 'streetClientError', 'A rua é obrigatória.')">
                <div class="error-message" th:if="${#fields.hasErrors('billingAddress.street')}" th:errors="*{billingAddress.street}"></div>
                <div id="streetClientError" class="error-message client-side-only" style="display: none;"></div>
            </div>

            <div class="mb-3">
                <label for="number" class="form-label">Número</label>
                <input type="text" id="number" th:field="*{billingAddress.number}" class="form-control"
                       th:classappend="${#fields.hasErrors('billingAddress.number')} ? 'field-error'" required
                       oninput="handleFieldInput(this, 'billingAddress.number')"
                       oninvalid="handleFieldInvalid(this, 'numberClientError', 'O número é obrigatório.')">
                <div class="error-message" th:if="${#fields.hasErrors('billingAddress.number')}" th:errors="*{billingAddress.number}"></div>
                <div id="numberClientError" class="error-message client-side-only" style="display: none;"></div>
            </div>

            <div class="mb-3">
                <label for="complement" class="form-label">Complemento</label>
                <input type="text" id="complement" th:field="*{billingAddress.complement}" class="form-control"
                       th:classappend="${#fields.hasErrors('billingAddress.complement')} ? 'field-error'"
                       oninput="handleFieldInput(this, 'billingAddress.complement')"> <!-- Não é obrigatório, sem oninvalid -->
                <div class="error-message" th:if="${#fields.hasErrors('billingAddress.complement')}" th:errors="*{billingAddress.complement}"></div>
            </div>

            <div class="mb-3">
                <label for="district" class="form-label">Bairro</label>
                <input type="text" id="district" th:field="*{billingAddress.district}" class="form-control"
                       th:classappend="${#fields.hasErrors('billingAddress.district')} ? 'field-error'" required
                       oninput="handleFieldInput(this, 'billingAddress.district')"
                       oninvalid="handleFieldInvalid(this, 'districtClientError', 'O bairro é obrigatório.')">
                <div class="error-message" th:if="${#fields.hasErrors('billingAddress.district')}" th:errors="*{billingAddress.district}"></div>
                <div id="districtClientError" class="error-message client-side-only" style="display: none;"></div>
            </div>

            <div class="mb-3">
                <label for="city" class="form-label">Cidade</label>
                <input type="text" id="city" th:field="*{billingAddress.city}" class="form-control"
                       th:classappend="${#fields.hasErrors('billingAddress.city')} ? 'field-error'" required
                       oninput="handleFieldInput(this, 'billingAddress.city')"
                       oninvalid="handleFieldInvalid(this, 'cityClientError', 'A cidade é obrigatória.')">
                <div class="error-message" th:if="${#fields.hasErrors('billingAddress.city')}" th:errors="*{billingAddress.city}"></div>
                <div id="cityClientError" class="error-message client-side-only" style="display: none;"></div>
            </div>

            <div class="mb-3">
                <label for="state" class="form-label">Estado</label>
                <input type="text" id="state" th:field="*{billingAddress.state}" class="form-control"
                       th:classappend="${#fields.hasErrors('billingAddress.state')} ? 'field-error'" required
                       oninput="handleFieldInput(this, 'billingAddress.state')"
                       oninvalid="handleFieldInvalid(this, 'stateClientError', 'O estado é obrigatório.')">
                <div class="error-message" th:if="${#fields.hasErrors('billingAddress.state')}" th:errors="*{billingAddress.state}"></div>
                <div id="stateClientError" class="error-message client-side-only" style="display: none;"></div>
            </div>

            <div class="mb-3">
                <label for="country" class="form-label">País</label>
                <input type="text" id="country" th:field="*{billingAddress.country}" class="form-control"
                       th:classappend="${#fields.hasErrors('billingAddress.country')} ? 'field-error'" required
                       oninput="handleFieldInput(this, 'billingAddress.country')"
                       oninvalid="handleFieldInvalid(this, 'countryClientError', 'O país é obrigatório.')">
                <div class="error-message" th:if="${#fields.hasErrors('billingAddress.country')}" th:errors="*{billingAddress.country}"></div>
                <div id="countryClientError" class="error-message client-side-only" style="display: none;"></div>
            </div>

            <input type="hidden" th:field="*{billingAddress.default}" value="true" />

            <div class="mb-3">
                <label for="addressType" class="form-label">Tipo de Endereço</label>
                <select id="addressType" th:field="*{billingAddress.type}" class="form-select"
                        aria-label="Tipo de endereço"
                        oninput="handleFieldInput(this, 'billingAddress.type')"
                        oninvalid="handleFieldInvalid(this, 'addressTypeClientError', 'O tipo de endereço é obrigatório.')"
                        th:classappend="${#fields.hasErrors('billingAddress.type')} ? 'field-error'" required>
                    <option value="">Selecione</option>
                    <option value="ENTREGA">Entrega</option>
                    <option value="FATURAMENTO">Faturamento</option>
                </select>

                <div class="error-message" th:if="${#fields.hasErrors('billingAddress.type')}" th:errors="*{billingAddress.type}"></div>
                <div id="addressTypeClientError" class="error-message client-side-only" style="display: none;"></div>
            </div>

            <div class="mb-3 form-check">
                <input type="checkbox" id="isDefault" class="form-check-input" th:field="*{billingAddress.default}">
                <label for="isDefault" class="form-check-label">Usar como endereço padrão</label>
            </div>

            <button type="submit" class="btn btn-success">Cadastrar</button>
        </form>
    </div>
</div>

<!-- Footer -->
<div th:replace="~{fragments/footer :: footer}"></div>

<script>
    // Funções de máscara (existentes)
    function applyCpfMask(input) { let value = input.value.replace(/\D/g, ''); if (value.length > 11) value = value.slice(0, 11); value = value.replace(/^(\d{3})(\d)/, '$1.$2'); value = value.replace(/^(\d{3})\.(\d{3})(\d)/, '$1.$2.$3'); value = value.replace(/^(\d{3})\.(\d{3})\.(\d{3})(\d)/, '$1.$2.$3-$4'); input.value = value; }
    function applyPhoneMask(input) { let value = input.value.replace(/\D/g, ''); if (value.length > 11) value = value.slice(0, 11); value = value.replace(/^(\d{2})(\d)/, '($1) $2'); value = value.replace(/(\d{5})(\d)/, '$1-$2'); input.value = value; }
    function applyCepMask(input) { let value = input.value.replace(/\D/g, ''); if (value.length > 8) value = value.slice(0, 8); if (value.length > 5) { value = value.replace(/^(\d{5})(\d)/, '$1-$2'); } input.value = value; }

    // Função buscarCep (existente)
    async function buscarCep() {
        const cep = document.getElementById("cep").value.trim().replace(/\D/g, '');
        if (!cep || cep.length !== 8) { alert("Digite um CEP válido."); return; }
        try {
            const res = await fetch(`/cep/${cep}`);
            if (!res.ok) throw new Error('Erro na busca do CEP');
            const data = await res.json();
            const campos = { street: 'street', district: 'district', city: 'city', state: 'state', country: 'country' };
            let primeiroCampoVazio = null;
            for (const prop in campos) {
                const inputId = campos[prop]; const inputEl = document.getElementById(inputId);
                const valor = data[prop] || ''; inputEl.value = valor;
                if (!primeiroCampoVazio && valor === '') { primeiroCampoVazio = inputEl; }
            }
            (primeiroCampoVazio || document.getElementById("number")).focus();
        } catch (err) { console.error(err); alert("Erro ao buscar o CEP. Verifique se o CEP está correto."); }
    }

    // Função de validação de CPF (existente)
    function isValidCPF(cpf) {
        cpf = cpf.replace(/\D/g, '');
        if (cpf.length !== 11) return false;
        if (/^(\d)\1{10}$/.test(cpf)) return false;
        let sum = 0; for (let i = 0; i < 9; i++) { sum += parseInt(cpf.charAt(i)) * (10 - i); }
        let remainder = sum % 11; const digit1 = remainder < 2 ? 0 : 11 - remainder;
        sum = 0; for (let i = 0; i < 10; i++) { sum += parseInt(cpf.charAt(i)) * (11 - i); }
        remainder = sum % 11; const digit2 = remainder < 2 ? 0 : 11 - remainder;
        return parseInt(cpf.charAt(9)) === digit1 && parseInt(cpf.charAt(10)) === digit2;
    }

    // Função unificada para validar campo de CPF no onblur (existente, mas adaptada para usar o ID do span)
    function validateCPF(input, clientErrorSpanId) {
        const errorElement = document.getElementById(clientErrorSpanId);
        const cpfValue = input.value.replace(/\D/g, '');

        if (!errorElement) return true; // Não há onde mostrar erro

        if (cpfValue.length === 0 && input.required) { // Se for obrigatório e vazio, deixa oninvalid tratar
            errorElement.style.display = 'none';
            // input.classList.remove("field-error"); // oninvalid cuidará disso
            return true;
        }
        if (cpfValue.length === 0 && !input.required) { // Não obrigatório e vazio
            errorElement.style.display = 'none';
            input.classList.remove("field-error");
            return true;
        }

        if (cpfValue.length < 11 || !isValidCPF(cpfValue)) {
            errorElement.textContent = 'CPF inválido.';
            errorElement.style.display = 'block';
            input.classList.add("field-error");
            return false;
        } else {
            errorElement.style.display = 'none';
            input.classList.remove("field-error");
            return true;
        }
    }

    // --- NOVAS/REFATORADAS FUNÇÕES DE VALIDAÇÃO DO CLIENTE ---

    function clearError(fieldName) {
        const field = document.querySelector(`[name='${fieldName}']`);
        if (!field) return;

        // Limpa a validade customizada do navegador
        if (typeof field.setCustomValidity === 'function') {
            field.setCustomValidity('');
        }
        field.classList.remove('field-error');

        // Limpa div de erro do Thymeleaf (gerado pelo servidor)
        let thymeleafErrorElement = null;
        let currentElement = field.nextElementSibling;
        while (currentElement) {
            if (currentElement.classList.contains('error-message') && !currentElement.classList.contains('client-side-only')) {
                thymeleafErrorElement = currentElement;
                break;
            }
            currentElement = currentElement.nextElementSibling;
        }
        if (thymeleafErrorElement) {
            thymeleafErrorElement.textContent = '';
        }

        // Limpa div de erro do cliente (gerado por JS)
        const clientErrorDivId = field.id + 'ClientError'; // Convenção: idDoCampoClientError
        const clientErrorDiv = document.getElementById(clientErrorDivId);
        if (clientErrorDiv) {
            clientErrorDiv.textContent = '';
            clientErrorDiv.style.display = 'none';
        }

        // Caso específico do CPF que usa um span diferente para o erro de formato
        if (field.id === 'cpf') {
            const cpfFormatErrorSpan = document.getElementById('cpfClientErrorSpan');
            if (cpfFormatErrorSpan) {
                cpfFormatErrorSpan.style.display = 'none';
            }
            const cpfRequiredErrorDiv = document.getElementById('cpfClientErrorDiv');
            if(cpfRequiredErrorDiv) {
                cpfRequiredErrorDiv.style.display = 'none';
            }
        }
    }

    function handleFieldInput(inputElement, fieldName) {
        if (typeof inputElement.setCustomValidity === 'function') {
            inputElement.setCustomValidity('');
        }
        // O fieldName aqui deve ser o que o th:field usa (ex: 'fullName', 'billingAddress.cep')
        clearError(fieldName);
    }

    function handleFieldInvalid(inputElement, clientErrorDivId, message) {
        if (inputElement.validity.valueMissing) { // Verifica se o erro é de campo obrigatório
            inputElement.setCustomValidity(message);
        } else if (inputElement.validity.typeMismatch) {
            inputElement.setCustomValidity("Formato inválido para este campo.");
        } else if (inputElement.validity.patternMismatch) {
            inputElement.setCustomValidity("O valor não corresponde ao padrão exigido.");
        } else {
            inputElement.setCustomValidity(message); // Mensagem genérica para outros erros
        }

        const clientErrorDiv = document.getElementById(clientErrorDivId);
        if (clientErrorDiv) {
            clientErrorDiv.textContent = inputElement.validationMessage; // Usa a mensagem definida pelo setCustomValidity
            clientErrorDiv.style.display = 'block';
        }
        inputElement.classList.add('field-error');
    }

    function handleDateInput(inputElement) { // Chamada no oninput do campo de data
        inputElement.setCustomValidity(''); // Limpa validade customizada

        const clientErrorDiv = document.getElementById('dateBirthClientError');
        if (clientErrorDiv) {
            clientErrorDiv.textContent = '';
            clientErrorDiv.style.display = 'none';
        }
        // clearError('dateBirth') será chamado pelo handleFieldInput que é chamado em sequência
    }

    function handleDateInvalid(inputElement, requiredMessage) { // Chamada no oninvalid do campo de data
        let message = '';
        if (inputElement.validity.valueMissing) {
            message = requiredMessage; // Mensagem de "campo obrigatório"
        } else if (inputElement.validity.badInput) {
            message = 'Data inválida. Verifique se o dia e o mês existem (ex: 31/02 não é válido).';
        } else if (inputElement.validity.rangeOverflow) {
            message = 'A data não pode ser no futuro.';
        } else if (inputElement.validity.rangeUnderflow) {
            message = 'A data é muito antiga.';
        } else {
            message = 'Por favor, insira uma data válida.'; // Genérico
        }

        inputElement.setCustomValidity(message);

        const clientErrorDiv = document.getElementById('dateBirthClientError');
        if (clientErrorDiv) {
            clientErrorDiv.textContent = message;
            clientErrorDiv.style.display = 'block';
        }
        inputElement.classList.add('field-error');
    }

    // Inicialização quando a página carrega (existente, sem mudanças drásticas necessárias aqui)
    document.addEventListener('DOMContentLoaded', function() {
        const cpfInput = document.getElementById('cpf');
        if (cpfInput) {
            cpfInput.addEventListener('blur', function() {
                validateCPF(this, 'cpfClientErrorSpan');
            });
        }
        // Outras inicializações como event listeners de submit podem ser mantidas ou ajustadas conforme necessidade.
        // O formulário com novalidate não vai disparar validação nativa no submit,
        // então se você quiser validação JS antes do envio, precisaria adicionar um event listener no submit do form.
        // Por agora, estamos confiando no oninvalid e no envio para o backend.
    });
</script>
</body>
</html>
